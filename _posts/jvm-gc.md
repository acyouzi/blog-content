---
title: jvm垃圾收集与内存分配
date: 2016-11-05 16:35:56
author: "acyouzi"
# cdn: header-off
# header-img: img/dog.jpg
tags:
	- jvm
	- 垃圾收集
---

### 对象还活着吗
这个问题是垃圾收集需要解决的第一个问题，一般来讲判断一个对象是否还能被访问到有如下两个方法：

### 引用计数算法
引用计数算法：通过给对象添加一个引用计数器，每当有一个地方引用计数器加一，引用失效时减一。

这种算法实现简单判定效率高，很多编程语言(如python)都采用这种这种算法进行内存管理，但是他很难解决对象之间相互循环引用的问题，所以java的主流虚拟机没有选用这种算法进行内存管理的
//循环引用图

### 可达性分析算法
可达性分析算法：通过一些列称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC root没有任何引用链相连则判定为不可达。

GC Roots 对象包括：
* 虚拟机栈
* 方法区中静态属性引用对象
* 方法区中常量引用的对象
* 本地方法栈JNI引用的对象

### 强引用，软引用，弱引用，虚引用
// 下一步翻译一篇关于引用的文章
强引用：只要引用还在永远不会被回收
软引用：由 SoftReference 类实现，在将要发生内存溢出之前会被回收
弱引用：由 WeakReference 类实现，只要垃圾回收工作就会被回收
虚引用：由 PhantomReference 类实现，唯一的作用就是能在这个对象被收集器回收时收到一个系统通知。

### 回收过程
1. 第一次标记：对象在进行可达性分析后发现没有与gc root相连，则进行第一次标记，然后判断需不需要执行finalize方法，如果对象没有覆盖finalize方法，或者finalize方法已经被调用过则被视为无需执行。
2. 如果需要执行finalize方法，则对象会被放到一个队列里面，并且在后面会被一个Finalizer线程去调用执行他。若在finalize方法中重新建立引用关系则可以避免被回收。
	
	实际上finalize方法并不保证一定会执行，最好忘记这个方法。
	// 下一步翻译一篇关于finalize的文章
3. 然后GC会对这个队列进行一个小范围的第二次标记，如果发现重新建立了引用关系则把对象移出待回收集合。

### 垃圾收集算法
垃圾收集算法主要有标记-清除算法、复制算法、标记整理算法、分代收集算法，其思想都比较直观容易理解。

1. 标记清除算法：
	顾名思义，分为标记和清除两个阶段，这种算法的问题一个是效率不高，另一个是内存碎片。
2. 复制算法：
	最简单的复制是把内存划分为容量相等的两块，每次使用其中一块，然后清理时把还存活的对象复制到另一块上面。

	商业虚拟机一般都会实现这种算法，但是并不是按照 1:1 的比例划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。当回收时，Eden 空间和一块 Survivor 空间存活的对象一次性的复制到另一块 Survivor 空间上。

	HotSpot虚拟机 Eden 和两个 Survivor 空间默认的比例是 8:1:1
3. 标记这里算法：
	从标记清除算法改进而来，其目的是通过整理过程避免出现内存碎片
4. 分代收集算法：
	根据对象活动周期不同把对象分为两类，每一类放在不同的内存块，采用不同的垃圾收集算法。
	一般会分为新生代和老年代，新生代的特点是会有大量对象生成和死去，对象生命周期短。老年代的特点是对象存活率比较高。

### 具体算法